<?php
// These stubs were generated by the phan stub generator.
// @phan-stub-for-extension intl@8.2.9

namespace {
class Collator {

    // constants
    const DEFAULT_VALUE = -1;
    const PRIMARY = 0;
    const SECONDARY = 1;
    const TERTIARY = 2;
    const DEFAULT_STRENGTH = 2;
    const QUATERNARY = 3;
    const IDENTICAL = 15;
    const OFF = 16;
    const ON = 17;
    const SHIFTED = 20;
    const NON_IGNORABLE = 21;
    const LOWER_FIRST = 24;
    const UPPER_FIRST = 25;
    const FRENCH_COLLATION = 0;
    const ALTERNATE_HANDLING = 1;
    const CASE_FIRST = 2;
    const CASE_LEVEL = 3;
    const NORMALIZATION_MODE = 4;
    const STRENGTH = 5;
    const HIRAGANA_QUATERNARY_MODE = 6;
    const NUMERIC_COLLATION = 7;
    const SORT_REGULAR = 0;
    const SORT_STRING = 1;
    const SORT_NUMERIC = 2;

    // properties
    public $name;

    // methods
    public function __construct(string $locale) {}
    public static function create(string $locale) : ?\Collator {}
    public function compare(string $string1, string $string2) : false|int {}
    public function sort(array &$array, int $flags = \Collator::SORT_REGULAR) : bool {}
    public function sortWithSortKeys(array &$array) : bool {}
    public function asort(array &$array, int $flags = \Collator::SORT_REGULAR) : bool {}
    public function getAttribute(int $attribute) : false|int {}
    public function setAttribute(int $attribute, int $value) : bool {}
    public function getStrength() : int {}
    public function setStrength(int $strength) {}
    public function getLocale(int $type) : false|string {}
    public function getErrorCode() : false|int {}
    public function getErrorMessage() : false|string {}
    public function getSortKey(string $string) : false|string {}
}

class IntlBreakIterator implements \IteratorAggregate, \Traversable {

    // constants
    const DONE = -1;
    const WORD_NONE = 0;
    const WORD_NONE_LIMIT = 100;
    const WORD_NUMBER = 100;
    const WORD_NUMBER_LIMIT = 200;
    const WORD_LETTER = 200;
    const WORD_LETTER_LIMIT = 300;
    const WORD_KANA = 300;
    const WORD_KANA_LIMIT = 400;
    const WORD_IDEO = 400;
    const WORD_IDEO_LIMIT = 500;
    const LINE_SOFT = 0;
    const LINE_SOFT_LIMIT = 100;
    const LINE_HARD = 100;
    const LINE_HARD_LIMIT = 200;
    const SENTENCE_TERM = 0;
    const SENTENCE_TERM_LIMIT = 100;
    const SENTENCE_SEP = 100;
    const SENTENCE_SEP_LIMIT = 200;

    // methods
    public static function createCharacterInstance(?string $locale = null) : ?\IntlBreakIterator {}
    public static function createCodePointInstance() : \IntlCodePointBreakIterator {}
    public static function createLineInstance(?string $locale = null) : ?\IntlBreakIterator {}
    public static function createSentenceInstance(?string $locale = null) : ?\IntlBreakIterator {}
    public static function createTitleInstance(?string $locale = null) : ?\IntlBreakIterator {}
    public static function createWordInstance(?string $locale = null) : ?\IntlBreakIterator {}
    private function __construct() {}
    public function current() : int {}
    public function first() : int {}
    public function following(int $offset) : int {}
    public function getErrorCode() : int {}
    public function getErrorMessage() : string {}
    public function getLocale(int $type) : false|string {}
    public function getPartsIterator(string $type = \IntlPartsIterator::KEY_SEQUENTIAL) : \IntlPartsIterator {}
    public function getText() : ?string {}
    public function isBoundary(int $offset) : bool {}
    public function last() : int {}
    public function next(?int $offset = null) : int {}
    public function preceding(int $offset) : int {}
    public function previous() : int {}
    public function setText(string $text) : ?bool {}
    public function getIterator() : \Iterator {}
}

class IntlCalendar {

    // constants
    const FIELD_ERA = 0;
    const FIELD_YEAR = 1;
    const FIELD_MONTH = 2;
    const FIELD_WEEK_OF_YEAR = 3;
    const FIELD_WEEK_OF_MONTH = 4;
    const FIELD_DATE = 5;
    const FIELD_DAY_OF_YEAR = 6;
    const FIELD_DAY_OF_WEEK = 7;
    const FIELD_DAY_OF_WEEK_IN_MONTH = 8;
    const FIELD_AM_PM = 9;
    const FIELD_HOUR = 10;
    const FIELD_HOUR_OF_DAY = 11;
    const FIELD_MINUTE = 12;
    const FIELD_SECOND = 13;
    const FIELD_MILLISECOND = 14;
    const FIELD_ZONE_OFFSET = 15;
    const FIELD_DST_OFFSET = 16;
    const FIELD_YEAR_WOY = 17;
    const FIELD_DOW_LOCAL = 18;
    const FIELD_EXTENDED_YEAR = 19;
    const FIELD_JULIAN_DAY = 20;
    const FIELD_MILLISECONDS_IN_DAY = 21;
    const FIELD_IS_LEAP_MONTH = 22;
    const FIELD_FIELD_COUNT = 23;
    const FIELD_DAY_OF_MONTH = 5;
    const DOW_SUNDAY = 1;
    const DOW_MONDAY = 2;
    const DOW_TUESDAY = 3;
    const DOW_WEDNESDAY = 4;
    const DOW_THURSDAY = 5;
    const DOW_FRIDAY = 6;
    const DOW_SATURDAY = 7;
    const DOW_TYPE_WEEKDAY = 0;
    const DOW_TYPE_WEEKEND = 1;
    const DOW_TYPE_WEEKEND_OFFSET = 2;
    const DOW_TYPE_WEEKEND_CEASE = 3;
    const WALLTIME_FIRST = 1;
    const WALLTIME_LAST = 0;
    const WALLTIME_NEXT_VALID = 2;

    // methods
    private function __construct() {}
    public static function createInstance($timezone = null, ?string $locale = null) : ?\IntlCalendar {}
    public function equals(\IntlCalendar $other) : bool {}
    public function fieldDifference(float $timestamp, int $field) : false|int {}
    public function add(int $field, int $value) : bool {}
    public function after(\IntlCalendar $other) : bool {}
    public function before(\IntlCalendar $other) : bool {}
    public function clear(?int $field = null) {}
    public static function fromDateTime(\DateTime|string $datetime, ?string $locale = null) : ?\IntlCalendar {}
    public function get(int $field) : false|int {}
    public function getActualMaximum(int $field) : false|int {}
    public function getActualMinimum(int $field) : false|int {}
    public static function getAvailableLocales() : array {}
    public function getDayOfWeekType(int $dayOfWeek) : false|int {}
    public function getErrorCode() : false|int {}
    public function getErrorMessage() : false|string {}
    public function getFirstDayOfWeek() : false|int {}
    public function getGreatestMinimum(int $field) : false|int {}
    public static function getKeywordValuesForLocale(string $keyword, string $locale, bool $onlyCommon) : \IntlIterator|false {}
    public function getLeastMaximum(int $field) : false|int {}
    public function getLocale(int $type) : false|string {}
    public function getMaximum(int $field) : false|int {}
    public function getMinimalDaysInFirstWeek() : false|int {}
    public function setMinimalDaysInFirstWeek(int $days) {}
    public function getMinimum(int $field) : false|int {}
    public static function getNow() : float {}
    public function getRepeatedWallTimeOption() : int {}
    public function getSkippedWallTimeOption() : int {}
    public function getTime() : false|float {}
    public function getTimeZone() : \IntlTimeZone|false {}
    public function getType() : string {}
    public function getWeekendTransition(int $dayOfWeek) : false|int {}
    public function inDaylightTime() : bool {}
    public function isEquivalentTo(\IntlCalendar $other) : bool {}
    public function isLenient() : bool {}
    public function isWeekend(?float $timestamp = null) : bool {}
    public function roll(int $field, $value) : bool {}
    public function isSet(int $field) : bool {}
    public function set(int $year, int $month, int $dayOfMonth = unknown, int $hour = unknown, int $minute = unknown, int $second = unknown) {}
    public function setFirstDayOfWeek(int $dayOfWeek) {}
    public function setLenient(bool $lenient) {}
    public function setRepeatedWallTimeOption(int $option) {}
    public function setSkippedWallTimeOption(int $option) {}
    public function setTime(float $timestamp) : bool {}
    public function setTimeZone($timezone) : bool {}
    public function toDateTime() : \DateTime|false {}
}

class IntlChar {

    // constants
    const UNICODE_VERSION = '12.1';
    const CODEPOINT_MIN = 0;
    const CODEPOINT_MAX = 1114111;
    const NO_NUMERIC_VALUE = -123456789.0;
    const PROPERTY_ALPHABETIC = 0;
    const PROPERTY_BINARY_START = 0;
    const PROPERTY_ASCII_HEX_DIGIT = 1;
    const PROPERTY_BIDI_CONTROL = 2;
    const PROPERTY_BIDI_MIRRORED = 3;
    const PROPERTY_DASH = 4;
    const PROPERTY_DEFAULT_IGNORABLE_CODE_POINT = 5;
    const PROPERTY_DEPRECATED = 6;
    const PROPERTY_DIACRITIC = 7;
    const PROPERTY_EXTENDER = 8;
    const PROPERTY_FULL_COMPOSITION_EXCLUSION = 9;
    const PROPERTY_GRAPHEME_BASE = 10;
    const PROPERTY_GRAPHEME_EXTEND = 11;
    const PROPERTY_GRAPHEME_LINK = 12;
    const PROPERTY_HEX_DIGIT = 13;
    const PROPERTY_HYPHEN = 14;
    const PROPERTY_ID_CONTINUE = 15;
    const PROPERTY_ID_START = 16;
    const PROPERTY_IDEOGRAPHIC = 17;
    const PROPERTY_IDS_BINARY_OPERATOR = 18;
    const PROPERTY_IDS_TRINARY_OPERATOR = 19;
    const PROPERTY_JOIN_CONTROL = 20;
    const PROPERTY_LOGICAL_ORDER_EXCEPTION = 21;
    const PROPERTY_LOWERCASE = 22;
    const PROPERTY_MATH = 23;
    const PROPERTY_NONCHARACTER_CODE_POINT = 24;
    const PROPERTY_QUOTATION_MARK = 25;
    const PROPERTY_RADICAL = 26;
    const PROPERTY_SOFT_DOTTED = 27;
    const PROPERTY_TERMINAL_PUNCTUATION = 28;
    const PROPERTY_UNIFIED_IDEOGRAPH = 29;
    const PROPERTY_UPPERCASE = 30;
    const PROPERTY_WHITE_SPACE = 31;
    const PROPERTY_XID_CONTINUE = 32;
    const PROPERTY_XID_START = 33;
    const PROPERTY_CASE_SENSITIVE = 34;
    const PROPERTY_S_TERM = 35;
    const PROPERTY_VARIATION_SELECTOR = 36;
    const PROPERTY_NFD_INERT = 37;
    const PROPERTY_NFKD_INERT = 38;
    const PROPERTY_NFC_INERT = 39;
    const PROPERTY_NFKC_INERT = 40;
    const PROPERTY_SEGMENT_STARTER = 41;
    const PROPERTY_PATTERN_SYNTAX = 42;
    const PROPERTY_PATTERN_WHITE_SPACE = 43;
    const PROPERTY_POSIX_ALNUM = 44;
    const PROPERTY_POSIX_BLANK = 45;
    const PROPERTY_POSIX_GRAPH = 46;
    const PROPERTY_POSIX_PRINT = 47;
    const PROPERTY_POSIX_XDIGIT = 48;
    const PROPERTY_CASED = 49;
    const PROPERTY_CASE_IGNORABLE = 50;
    const PROPERTY_CHANGES_WHEN_LOWERCASED = 51;
    const PROPERTY_CHANGES_WHEN_UPPERCASED = 52;
    const PROPERTY_CHANGES_WHEN_TITLECASED = 53;
    const PROPERTY_CHANGES_WHEN_CASEFOLDED = 54;
    const PROPERTY_CHANGES_WHEN_CASEMAPPED = 55;
    const PROPERTY_CHANGES_WHEN_NFKC_CASEFOLDED = 56;
    const PROPERTY_BINARY_LIMIT = 65;
    const PROPERTY_BIDI_CLASS = 4096;
    const PROPERTY_INT_START = 4096;
    const PROPERTY_BLOCK = 4097;
    const PROPERTY_CANONICAL_COMBINING_CLASS = 4098;
    const PROPERTY_DECOMPOSITION_TYPE = 4099;
    const PROPERTY_EAST_ASIAN_WIDTH = 4100;
    const PROPERTY_GENERAL_CATEGORY = 4101;
    const PROPERTY_JOINING_GROUP = 4102;
    const PROPERTY_JOINING_TYPE = 4103;
    const PROPERTY_LINE_BREAK = 4104;
    const PROPERTY_NUMERIC_TYPE = 4105;
    const PROPERTY_SCRIPT = 4106;
    const PROPERTY_HANGUL_SYLLABLE_TYPE = 4107;
    const PROPERTY_NFD_QUICK_CHECK = 4108;
    const PROPERTY_NFKD_QUICK_CHECK = 4109;
    const PROPERTY_NFC_QUICK_CHECK = 4110;
    const PROPERTY_NFKC_QUICK_CHECK = 4111;
    const PROPERTY_LEAD_CANONICAL_COMBINING_CLASS = 4112;
    const PROPERTY_TRAIL_CANONICAL_COMBINING_CLASS = 4113;
    const PROPERTY_GRAPHEME_CLUSTER_BREAK = 4114;
    const PROPERTY_SENTENCE_BREAK = 4115;
    const PROPERTY_WORD_BREAK = 4116;
    const PROPERTY_BIDI_PAIRED_BRACKET_TYPE = 4117;
    const PROPERTY_INT_LIMIT = 4121;
    const PROPERTY_GENERAL_CATEGORY_MASK = 8192;
    const PROPERTY_MASK_START = 8192;
    const PROPERTY_MASK_LIMIT = 8193;
    const PROPERTY_NUMERIC_VALUE = 12288;
    const PROPERTY_DOUBLE_START = 12288;
    const PROPERTY_DOUBLE_LIMIT = 12289;
    const PROPERTY_AGE = 16384;
    const PROPERTY_STRING_START = 16384;
    const PROPERTY_BIDI_MIRRORING_GLYPH = 16385;
    const PROPERTY_CASE_FOLDING = 16386;
    const PROPERTY_ISO_COMMENT = 16387;
    const PROPERTY_LOWERCASE_MAPPING = 16388;
    const PROPERTY_NAME = 16389;
    const PROPERTY_SIMPLE_CASE_FOLDING = 16390;
    const PROPERTY_SIMPLE_LOWERCASE_MAPPING = 16391;
    const PROPERTY_SIMPLE_TITLECASE_MAPPING = 16392;
    const PROPERTY_SIMPLE_UPPERCASE_MAPPING = 16393;
    const PROPERTY_TITLECASE_MAPPING = 16394;
    const PROPERTY_UNICODE_1_NAME = 16395;
    const PROPERTY_UPPERCASE_MAPPING = 16396;
    const PROPERTY_BIDI_PAIRED_BRACKET = 16397;
    const PROPERTY_STRING_LIMIT = 16398;
    const PROPERTY_SCRIPT_EXTENSIONS = 28672;
    const PROPERTY_OTHER_PROPERTY_START = 28672;
    const PROPERTY_OTHER_PROPERTY_LIMIT = 28673;
    const PROPERTY_INVALID_CODE = -1;
    const CHAR_CATEGORY_UNASSIGNED = 0;
    const CHAR_CATEGORY_GENERAL_OTHER_TYPES = 0;
    const CHAR_CATEGORY_UPPERCASE_LETTER = 1;
    const CHAR_CATEGORY_LOWERCASE_LETTER = 2;
    const CHAR_CATEGORY_TITLECASE_LETTER = 3;
    const CHAR_CATEGORY_MODIFIER_LETTER = 4;
    const CHAR_CATEGORY_OTHER_LETTER = 5;
    const CHAR_CATEGORY_NON_SPACING_MARK = 6;
    const CHAR_CATEGORY_ENCLOSING_MARK = 7;
    const CHAR_CATEGORY_COMBINING_SPACING_MARK = 8;
    const CHAR_CATEGORY_DECIMAL_DIGIT_NUMBER = 9;
    const CHAR_CATEGORY_LETTER_NUMBER = 10;
    const CHAR_CATEGORY_OTHER_NUMBER = 11;
    const CHAR_CATEGORY_SPACE_SEPARATOR = 12;
    const CHAR_CATEGORY_LINE_SEPARATOR = 13;
    const CHAR_CATEGORY_PARAGRAPH_SEPARATOR = 14;
    const CHAR_CATEGORY_CONTROL_CHAR = 15;
    const CHAR_CATEGORY_FORMAT_CHAR = 16;
    const CHAR_CATEGORY_PRIVATE_USE_CHAR = 17;
    const CHAR_CATEGORY_SURROGATE = 18;
    const CHAR_CATEGORY_DASH_PUNCTUATION = 19;
    const CHAR_CATEGORY_START_PUNCTUATION = 20;
    const CHAR_CATEGORY_END_PUNCTUATION = 21;
    const CHAR_CATEGORY_CONNECTOR_PUNCTUATION = 22;
    const CHAR_CATEGORY_OTHER_PUNCTUATION = 23;
    const CHAR_CATEGORY_MATH_SYMBOL = 24;
    const CHAR_CATEGORY_CURRENCY_SYMBOL = 25;
    const CHAR_CATEGORY_MODIFIER_SYMBOL = 26;
    const CHAR_CATEGORY_OTHER_SYMBOL = 27;
    const CHAR_CATEGORY_INITIAL_PUNCTUATION = 28;
    const CHAR_CATEGORY_FINAL_PUNCTUATION = 29;
    const CHAR_CATEGORY_CHAR_CATEGORY_COUNT = 30;
    const CHAR_DIRECTION_LEFT_TO_RIGHT = 0;
    const CHAR_DIRECTION_RIGHT_TO_LEFT = 1;
    const CHAR_DIRECTION_EUROPEAN_NUMBER = 2;
    const CHAR_DIRECTION_EUROPEAN_NUMBER_SEPARATOR = 3;
    const CHAR_DIRECTION_EUROPEAN_NUMBER_TERMINATOR = 4;
    const CHAR_DIRECTION_ARABIC_NUMBER = 5;
    const CHAR_DIRECTION_COMMON_NUMBER_SEPARATOR = 6;
    const CHAR_DIRECTION_BLOCK_SEPARATOR = 7;
    const CHAR_DIRECTION_SEGMENT_SEPARATOR = 8;
    const CHAR_DIRECTION_WHITE_SPACE_NEUTRAL = 9;
    const CHAR_DIRECTION_OTHER_NEUTRAL = 10;
    const CHAR_DIRECTION_LEFT_TO_RIGHT_EMBEDDING = 11;
    const CHAR_DIRECTION_LEFT_TO_RIGHT_OVERRIDE = 12;
    const CHAR_DIRECTION_RIGHT_TO_LEFT_ARABIC = 13;
    const CHAR_DIRECTION_RIGHT_TO_LEFT_EMBEDDING = 14;
    const CHAR_DIRECTION_RIGHT_TO_LEFT_OVERRIDE = 15;
    const CHAR_DIRECTION_POP_DIRECTIONAL_FORMAT = 16;
    const CHAR_DIRECTION_DIR_NON_SPACING_MARK = 17;
    const CHAR_DIRECTION_BOUNDARY_NEUTRAL = 18;
    const CHAR_DIRECTION_FIRST_STRONG_ISOLATE = 19;
    const CHAR_DIRECTION_LEFT_TO_RIGHT_ISOLATE = 20;
    const CHAR_DIRECTION_RIGHT_TO_LEFT_ISOLATE = 21;
    const CHAR_DIRECTION_POP_DIRECTIONAL_ISOLATE = 22;
    const CHAR_DIRECTION_CHAR_DIRECTION_COUNT = 23;
    const BLOCK_CODE_NO_BLOCK = 0;
    const BLOCK_CODE_BASIC_LATIN = 1;
    const BLOCK_CODE_LATIN_1_SUPPLEMENT = 2;
    const BLOCK_CODE_LATIN_EXTENDED_A = 3;
    const BLOCK_CODE_LATIN_EXTENDED_B = 4;
    const BLOCK_CODE_IPA_EXTENSIONS = 5;
    const BLOCK_CODE_SPACING_MODIFIER_LETTERS = 6;
    const BLOCK_CODE_COMBINING_DIACRITICAL_MARKS = 7;
    const BLOCK_CODE_GREEK = 8;
    const BLOCK_CODE_CYRILLIC = 9;
    const BLOCK_CODE_ARMENIAN = 10;
    const BLOCK_CODE_HEBREW = 11;
    const BLOCK_CODE_ARABIC = 12;
    const BLOCK_CODE_SYRIAC = 13;
    const BLOCK_CODE_THAANA = 14;
    const BLOCK_CODE_DEVANAGARI = 15;
    const BLOCK_CODE_BENGALI = 16;
    const BLOCK_CODE_GURMUKHI = 17;
    const BLOCK_CODE_GUJARATI = 18;
    const BLOCK_CODE_ORIYA = 19;
    const BLOCK_CODE_TAMIL = 20;
    const BLOCK_CODE_TELUGU = 21;
    const BLOCK_CODE_KANNADA = 22;
    const BLOCK_CODE_MALAYALAM = 23;
    const BLOCK_CODE_SINHALA = 24;
    const BLOCK_CODE_THAI = 25;
    const BLOCK_CODE_LAO = 26;
    const BLOCK_CODE_TIBETAN = 27;
    const BLOCK_CODE_MYANMAR = 28;
    const BLOCK_CODE_GEORGIAN = 29;
    const BLOCK_CODE_HANGUL_JAMO = 30;
    const BLOCK_CODE_ETHIOPIC = 31;
    const BLOCK_CODE_CHEROKEE = 32;
    const BLOCK_CODE_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS = 33;
    const BLOCK_CODE_OGHAM = 34;
    const BLOCK_CODE_RUNIC = 35;
    const BLOCK_CODE_KHMER = 36;
    const BLOCK_CODE_MONGOLIAN = 37;
    const BLOCK_CODE_LATIN_EXTENDED_ADDITIONAL = 38;
    const BLOCK_CODE_GREEK_EXTENDED = 39;
    const BLOCK_CODE_GENERAL_PUNCTUATION = 40;
    const BLOCK_CODE_SUPERSCRIPTS_AND_SUBSCRIPTS = 41;
    const BLOCK_CODE_CURRENCY_SYMBOLS = 42;
    const BLOCK_CODE_COMBINING_MARKS_FOR_SYMBOLS = 43;
    const BLOCK_CODE_LETTERLIKE_SYMBOLS = 44;
    const BLOCK_CODE_NUMBER_FORMS = 45;
    const BLOCK_CODE_ARROWS = 46;
    const BLOCK_CODE_MATHEMATICAL_OPERATORS = 47;
    const BLOCK_CODE_MISCELLANEOUS_TECHNICAL = 48;
    const BLOCK_CODE_CONTROL_PICTURES = 49;
    const BLOCK_CODE_OPTICAL_CHARACTER_RECOGNITION = 50;
    const BLOCK_CODE_ENCLOSED_ALPHANUMERICS = 51;
    const BLOCK_CODE_BOX_DRAWING = 52;
    const BLOCK_CODE_BLOCK_ELEMENTS = 53;
    const BLOCK_CODE_GEOMETRIC_SHAPES = 54;
    const BLOCK_CODE_MISCELLANEOUS_SYMBOLS = 55;
    const BLOCK_CODE_DINGBATS = 56;
    const BLOCK_CODE_BRAILLE_PATTERNS = 57;
    const BLOCK_CODE_CJK_RADICALS_SUPPLEMENT = 58;
    const BLOCK_CODE_KANGXI_RADICALS = 59;
    const BLOCK_CODE_IDEOGRAPHIC_DESCRIPTION_CHARACTERS = 60;
    const BLOCK_CODE_CJK_SYMBOLS_AND_PUNCTUATION = 61;
    const BLOCK_CODE_HIRAGANA = 62;
    const BLOCK_CODE_KATAKANA = 63;
    const BLOCK_CODE_BOPOMOFO = 64;
    const BLOCK_CODE_HANGUL_COMPATIBILITY_JAMO = 65;
    const BLOCK_CODE_KANBUN = 66;
    const BLOCK_CODE_BOPOMOFO_EXTENDED = 67;
    const BLOCK_CODE_ENCLOSED_CJK_LETTERS_AND_MONTHS = 68;
    const BLOCK_CODE_CJK_COMPATIBILITY = 69;
    const BLOCK_CODE_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A = 70;
    const BLOCK_CODE_CJK_UNIFIED_IDEOGRAPHS = 71;
    const BLOCK_CODE_YI_SYLLABLES = 72;
    const BLOCK_CODE_YI_RADICALS = 73;
    const BLOCK_CODE_HANGUL_SYLLABLES = 74;
    const BLOCK_CODE_HIGH_SURROGATES = 75;
    const BLOCK_CODE_HIGH_PRIVATE_USE_SURROGATES = 76;
    const BLOCK_CODE_LOW_SURROGATES = 77;
    const BLOCK_CODE_PRIVATE_USE_AREA = 78;
    const BLOCK_CODE_PRIVATE_USE = 78;
    const BLOCK_CODE_CJK_COMPATIBILITY_IDEOGRAPHS = 79;
    const BLOCK_CODE_ALPHABETIC_PRESENTATION_FORMS = 80;
    const BLOCK_CODE_ARABIC_PRESENTATION_FORMS_A = 81;
    const BLOCK_CODE_COMBINING_HALF_MARKS = 82;
    const BLOCK_CODE_CJK_COMPATIBILITY_FORMS = 83;
    const BLOCK_CODE_SMALL_FORM_VARIANTS = 84;
    const BLOCK_CODE_ARABIC_PRESENTATION_FORMS_B = 85;
    const BLOCK_CODE_SPECIALS = 86;
    const BLOCK_CODE_HALFWIDTH_AND_FULLWIDTH_FORMS = 87;
    const BLOCK_CODE_OLD_ITALIC = 88;
    const BLOCK_CODE_GOTHIC = 89;
    const BLOCK_CODE_DESERET = 90;
    const BLOCK_CODE_BYZANTINE_MUSICAL_SYMBOLS = 91;
    const BLOCK_CODE_MUSICAL_SYMBOLS = 92;
    const BLOCK_CODE_MATHEMATICAL_ALPHANUMERIC_SYMBOLS = 93;
    const BLOCK_CODE_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = 94;
    const BLOCK_CODE_CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = 95;
    const BLOCK_CODE_TAGS = 96;
    const BLOCK_CODE_CYRILLIC_SUPPLEMENT = 97;
    const BLOCK_CODE_CYRILLIC_SUPPLEMENTARY = 97;
    const BLOCK_CODE_TAGALOG = 98;
    const BLOCK_CODE_HANUNOO = 99;
    const BLOCK_CODE_BUHID = 100;
    const BLOCK_CODE_TAGBANWA = 101;
    const BLOCK_CODE_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = 102;
    const BLOCK_CODE_SUPPLEMENTAL_ARROWS_A = 103;
    const BLOCK_CODE_SUPPLEMENTAL_ARROWS_B = 104;
    const BLOCK_CODE_MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = 105;
    const BLOCK_CODE_SUPPLEMENTAL_MATHEMATICAL_OPERATORS = 106;
    const BLOCK_CODE_KATAKANA_PHONETIC_EXTENSIONS = 107;
    const BLOCK_CODE_VARIATION_SELECTORS = 108;
    const BLOCK_CODE_SUPPLEMENTARY_PRIVATE_USE_AREA_A = 109;
    const BLOCK_CODE_SUPPLEMENTARY_PRIVATE_USE_AREA_B = 110;
    const BLOCK_CODE_LIMBU = 111;
    const BLOCK_CODE_TAI_LE = 112;
    const BLOCK_CODE_KHMER_SYMBOLS = 113;
    const BLOCK_CODE_PHONETIC_EXTENSIONS = 114;
    const BLOCK_CODE_MISCELLANEOUS_SYMBOLS_AND_ARROWS = 115;
    const BLOCK_CODE_YIJING_HEXAGRAM_SYMBOLS = 116;
    const BLOCK_CODE_LINEAR_B_SYLLABARY = 117;
    const BLOCK_CODE_LINEAR_B_IDEOGRAMS = 118;
    const BLOCK_CODE_AEGEAN_NUMBERS = 119;
    const BLOCK_CODE_UGARITIC = 120;
    const BLOCK_CODE_SHAVIAN = 121;
    const BLOCK_CODE_OSMANYA = 122;
    const BLOCK_CODE_CYPRIOT_SYLLABARY = 123;
    const BLOCK_CODE_TAI_XUAN_JING_SYMBOLS = 124;
    const BLOCK_CODE_VARIATION_SELECTORS_SUPPLEMENT = 125;
    const BLOCK_CODE_ANCIENT_GREEK_MUSICAL_NOTATION = 126;
    const BLOCK_CODE_ANCIENT_GREEK_NUMBERS = 127;
    const BLOCK_CODE_ARABIC_SUPPLEMENT = 128;
    const BLOCK_CODE_BUGINESE = 129;
    const BLOCK_CODE_CJK_STROKES = 130;
    const BLOCK_CODE_COMBINING_DIACRITICAL_MARKS_SUPPLEMENT = 131;
    const BLOCK_CODE_COPTIC = 132;
    const BLOCK_CODE_ETHIOPIC_EXTENDED = 133;
    const BLOCK_CODE_ETHIOPIC_SUPPLEMENT = 134;
    const BLOCK_CODE_GEORGIAN_SUPPLEMENT = 135;
    const BLOCK_CODE_GLAGOLITIC = 136;
    const BLOCK_CODE_KHAROSHTHI = 137;
    const BLOCK_CODE_MODIFIER_TONE_LETTERS = 138;
    const BLOCK_CODE_NEW_TAI_LUE = 139;
    const BLOCK_CODE_OLD_PERSIAN = 140;
    const BLOCK_CODE_PHONETIC_EXTENSIONS_SUPPLEMENT = 141;
    const BLOCK_CODE_SUPPLEMENTAL_PUNCTUATION = 142;
    const BLOCK_CODE_SYLOTI_NAGRI = 143;
    const BLOCK_CODE_TIFINAGH = 144;
    const BLOCK_CODE_VERTICAL_FORMS = 145;
    const BLOCK_CODE_NKO = 146;
    const BLOCK_CODE_BALINESE = 147;
    const BLOCK_CODE_LATIN_EXTENDED_C = 148;
    const BLOCK_CODE_LATIN_EXTENDED_D = 149;
    const BLOCK_CODE_PHAGS_PA = 150;
    const BLOCK_CODE_PHOENICIAN = 151;
    const BLOCK_CODE_CUNEIFORM = 152;
    const BLOCK_CODE_CUNEIFORM_NUMBERS_AND_PUNCTUATION = 153;
    const BLOCK_CODE_COUNTING_ROD_NUMERALS = 154;
    const BLOCK_CODE_SUNDANESE = 155;
    const BLOCK_CODE_LEPCHA = 156;
    const BLOCK_CODE_OL_CHIKI = 157;
    const BLOCK_CODE_CYRILLIC_EXTENDED_A = 158;
    const BLOCK_CODE_VAI = 159;
    const BLOCK_CODE_CYRILLIC_EXTENDED_B = 160;
    const BLOCK_CODE_SAURASHTRA = 161;
    const BLOCK_CODE_KAYAH_LI = 162;
    const BLOCK_CODE_REJANG = 163;
    const BLOCK_CODE_CHAM = 164;
    const BLOCK_CODE_ANCIENT_SYMBOLS = 165;
    const BLOCK_CODE_PHAISTOS_DISC = 166;
    const BLOCK_CODE_LYCIAN = 167;
    const BLOCK_CODE_CARIAN = 168;
    const BLOCK_CODE_LYDIAN = 169;
    const BLOCK_CODE_MAHJONG_TILES = 170;
    const BLOCK_CODE_DOMINO_TILES = 171;
    const BLOCK_CODE_SAMARITAN = 172;
    const BLOCK_CODE_UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED = 173;
    const BLOCK_CODE_TAI_THAM = 174;
    const BLOCK_CODE_VEDIC_EXTENSIONS = 175;
    const BLOCK_CODE_LISU = 176;
    const BLOCK_CODE_BAMUM = 177;
    const BLOCK_CODE_COMMON_INDIC_NUMBER_FORMS = 178;
    const BLOCK_CODE_DEVANAGARI_EXTENDED = 179;
    const BLOCK_CODE_HANGUL_JAMO_EXTENDED_A = 180;
    const BLOCK_CODE_JAVANESE = 181;
    const BLOCK_CODE_MYANMAR_EXTENDED_A = 182;
    const BLOCK_CODE_TAI_VIET = 183;
    const BLOCK_CODE_MEETEI_MAYEK = 184;
    const BLOCK_CODE_HANGUL_JAMO_EXTENDED_B = 185;
    const BLOCK_CODE_IMPERIAL_ARAMAIC = 186;
    const BLOCK_CODE_OLD_SOUTH_ARABIAN = 187;
    const BLOCK_CODE_AVESTAN = 188;
    const BLOCK_CODE_INSCRIPTIONAL_PARTHIAN = 189;
    const BLOCK_CODE_INSCRIPTIONAL_PAHLAVI = 190;
    const BLOCK_CODE_OLD_TURKIC = 191;
    const BLOCK_CODE_RUMI_NUMERAL_SYMBOLS = 192;
    const BLOCK_CODE_KAITHI = 193;
    const BLOCK_CODE_EGYPTIAN_HIEROGLYPHS = 194;
    const BLOCK_CODE_ENCLOSED_ALPHANUMERIC_SUPPLEMENT = 195;
    const BLOCK_CODE_ENCLOSED_IDEOGRAPHIC_SUPPLEMENT = 196;
    const BLOCK_CODE_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C = 197;
    const BLOCK_CODE_MANDAIC = 198;
    const BLOCK_CODE_BATAK = 199;
    const BLOCK_CODE_ETHIOPIC_EXTENDED_A = 200;
    const BLOCK_CODE_BRAHMI = 201;
    const BLOCK_CODE_BAMUM_SUPPLEMENT = 202;
    const BLOCK_CODE_KANA_SUPPLEMENT = 203;
    const BLOCK_CODE_PLAYING_CARDS = 204;
    const BLOCK_CODE_MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS = 205;
    const BLOCK_CODE_EMOTICONS = 206;
    const BLOCK_CODE_TRANSPORT_AND_MAP_SYMBOLS = 207;
    const BLOCK_CODE_ALCHEMICAL_SYMBOLS = 208;
    const BLOCK_CODE_CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D = 209;
    const BLOCK_CODE_ARABIC_EXTENDED_A = 210;
    const BLOCK_CODE_ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS = 211;
    const BLOCK_CODE_CHAKMA = 212;
    const BLOCK_CODE_MEETEI_MAYEK_EXTENSIONS = 213;
    const BLOCK_CODE_MEROITIC_CURSIVE = 214;
    const BLOCK_CODE_MEROITIC_HIEROGLYPHS = 215;
    const BLOCK_CODE_MIAO = 216;
    const BLOCK_CODE_SHARADA = 217;
    const BLOCK_CODE_SORA_SOMPENG = 218;
    const BLOCK_CODE_SUNDANESE_SUPPLEMENT = 219;
    const BLOCK_CODE_TAKRI = 220;
    const BLOCK_CODE_BASSA_VAH = 221;
    const BLOCK_CODE_CAUCASIAN_ALBANIAN = 222;
    const BLOCK_CODE_COPTIC_EPACT_NUMBERS = 223;
    const BLOCK_CODE_COMBINING_DIACRITICAL_MARKS_EXTENDED = 224;
    const BLOCK_CODE_DUPLOYAN = 225;
    const BLOCK_CODE_ELBASAN = 226;
    const BLOCK_CODE_GEOMETRIC_SHAPES_EXTENDED = 227;
    const BLOCK_CODE_GRANTHA = 228;
    const BLOCK_CODE_KHOJKI = 229;
    const BLOCK_CODE_KHUDAWADI = 230;
    const BLOCK_CODE_LATIN_EXTENDED_E = 231;
    const BLOCK_CODE_LINEAR_A = 232;
    const BLOCK_CODE_MAHAJANI = 233;
    const BLOCK_CODE_MANICHAEAN = 234;
    const BLOCK_CODE_MENDE_KIKAKUI = 235;
    const BLOCK_CODE_MODI = 236;
    const BLOCK_CODE_MRO = 237;
    const BLOCK_CODE_MYANMAR_EXTENDED_B = 238;
    const BLOCK_CODE_NABATAEAN = 239;
    const BLOCK_CODE_OLD_NORTH_ARABIAN = 240;
    const BLOCK_CODE_OLD_PERMIC = 241;
    const BLOCK_CODE_ORNAMENTAL_DINGBATS = 242;
    const BLOCK_CODE_PAHAWH_HMONG = 243;
    const BLOCK_CODE_PALMYRENE = 244;
    const BLOCK_CODE_PAU_CIN_HAU = 245;
    const BLOCK_CODE_PSALTER_PAHLAVI = 246;
    const BLOCK_CODE_SHORTHAND_FORMAT_CONTROLS = 247;
    const BLOCK_CODE_SIDDHAM = 248;
    const BLOCK_CODE_SINHALA_ARCHAIC_NUMBERS = 249;
    const BLOCK_CODE_SUPPLEMENTAL_ARROWS_C = 250;
    const BLOCK_CODE_TIRHUTA = 251;
    const BLOCK_CODE_WARANG_CITI = 252;
    const BLOCK_CODE_COUNT = 301;
    const BLOCK_CODE_INVALID_CODE = -1;
    const BPT_NONE = 0;
    const BPT_OPEN = 1;
    const BPT_CLOSE = 2;
    const BPT_COUNT = 3;
    const EA_NEUTRAL = 0;
    const EA_AMBIGUOUS = 1;
    const EA_HALFWIDTH = 2;
    const EA_FULLWIDTH = 3;
    const EA_NARROW = 4;
    const EA_WIDE = 5;
    const EA_COUNT = 6;
    const UNICODE_CHAR_NAME = 0;
    const UNICODE_10_CHAR_NAME = 1;
    const EXTENDED_CHAR_NAME = 2;
    const CHAR_NAME_ALIAS = 3;
    const CHAR_NAME_CHOICE_COUNT = 4;
    const SHORT_PROPERTY_NAME = 0;
    const LONG_PROPERTY_NAME = 1;
    const PROPERTY_NAME_CHOICE_COUNT = 2;
    const DT_NONE = 0;
    const DT_CANONICAL = 1;
    const DT_COMPAT = 2;
    const DT_CIRCLE = 3;
    const DT_FINAL = 4;
    const DT_FONT = 5;
    const DT_FRACTION = 6;
    const DT_INITIAL = 7;
    const DT_ISOLATED = 8;
    const DT_MEDIAL = 9;
    const DT_NARROW = 10;
    const DT_NOBREAK = 11;
    const DT_SMALL = 12;
    const DT_SQUARE = 13;
    const DT_SUB = 14;
    const DT_SUPER = 15;
    const DT_VERTICAL = 16;
    const DT_WIDE = 17;
    const DT_COUNT = 18;
    const JT_NON_JOINING = 0;
    const JT_JOIN_CAUSING = 1;
    const JT_DUAL_JOINING = 2;
    const JT_LEFT_JOINING = 3;
    const JT_RIGHT_JOINING = 4;
    const JT_TRANSPARENT = 5;
    const JT_COUNT = 6;
    const JG_NO_JOINING_GROUP = 0;
    const JG_AIN = 1;
    const JG_ALAPH = 2;
    const JG_ALEF = 3;
    const JG_BEH = 4;
    const JG_BETH = 5;
    const JG_DAL = 6;
    const JG_DALATH_RISH = 7;
    const JG_E = 8;
    const JG_FEH = 9;
    const JG_FINAL_SEMKATH = 10;
    const JG_GAF = 11;
    const JG_GAMAL = 12;
    const JG_HAH = 13;
    const JG_TEH_MARBUTA_GOAL = 14;
    const JG_HAMZA_ON_HEH_GOAL = 14;
    const JG_HE = 15;
    const JG_HEH = 16;
    const JG_HEH_GOAL = 17;
    const JG_HETH = 18;
    const JG_KAF = 19;
    const JG_KAPH = 20;
    const JG_KNOTTED_HEH = 21;
    const JG_LAM = 22;
    const JG_LAMADH = 23;
    const JG_MEEM = 24;
    const JG_MIM = 25;
    const JG_NOON = 26;
    const JG_NUN = 27;
    const JG_PE = 28;
    const JG_QAF = 29;
    const JG_QAPH = 30;
    const JG_REH = 31;
    const JG_REVERSED_PE = 32;
    const JG_SAD = 33;
    const JG_SADHE = 34;
    const JG_SEEN = 35;
    const JG_SEMKATH = 36;
    const JG_SHIN = 37;
    const JG_SWASH_KAF = 38;
    const JG_SYRIAC_WAW = 39;
    const JG_TAH = 40;
    const JG_TAW = 41;
    const JG_TEH_MARBUTA = 42;
    const JG_TETH = 43;
    const JG_WAW = 44;
    const JG_YEH = 45;
    const JG_YEH_BARREE = 46;
    const JG_YEH_WITH_TAIL = 47;
    const JG_YUDH = 48;
    const JG_YUDH_HE = 49;
    const JG_ZAIN = 50;
    const JG_FE = 51;
    const JG_KHAPH = 52;
    const JG_ZHAIN = 53;
    const JG_BURUSHASKI_YEH_BARREE = 54;
    const JG_FARSI_YEH = 55;
    const JG_NYA = 56;
    const JG_ROHINGYA_YEH = 57;
    const JG_MANICHAEAN_ALEPH = 58;
    const JG_MANICHAEAN_AYIN = 59;
    const JG_MANICHAEAN_BETH = 60;
    const JG_MANICHAEAN_DALETH = 61;
    const JG_MANICHAEAN_DHAMEDH = 62;
    const JG_MANICHAEAN_FIVE = 63;
    const JG_MANICHAEAN_GIMEL = 64;
    const JG_MANICHAEAN_HETH = 65;
    const JG_MANICHAEAN_HUNDRED = 66;
    const JG_MANICHAEAN_KAPH = 67;
    const JG_MANICHAEAN_LAMEDH = 68;
    const JG_MANICHAEAN_MEM = 69;
    const JG_MANICHAEAN_NUN = 70;
    const JG_MANICHAEAN_ONE = 71;
    const JG_MANICHAEAN_PE = 72;
    const JG_MANICHAEAN_QOPH = 73;
    const JG_MANICHAEAN_RESH = 74;
    const JG_MANICHAEAN_SADHE = 75;
    const JG_MANICHAEAN_SAMEKH = 76;
    const JG_MANICHAEAN_TAW = 77;
    const JG_MANICHAEAN_TEN = 78;
    const JG_MANICHAEAN_TETH = 79;
    const JG_MANICHAEAN_THAMEDH = 80;
    const JG_MANICHAEAN_TWENTY = 81;
    const JG_MANICHAEAN_WAW = 82;
    const JG_MANICHAEAN_YODH = 83;
    const JG_MANICHAEAN_ZAYIN = 84;
    const JG_STRAIGHT_WAW = 85;
    const JG_COUNT = 102;
    const GCB_OTHER = 0;
    const GCB_CONTROL = 1;
    const GCB_CR = 2;
    const GCB_EXTEND = 3;
    const GCB_L = 4;
    const GCB_LF = 5;
    const GCB_LV = 6;
    const GCB_LVT = 7;
    const GCB_T = 8;
    const GCB_V = 9;
    const GCB_SPACING_MARK = 10;
    const GCB_PREPEND = 11;
    const GCB_REGIONAL_INDICATOR = 12;
    const GCB_COUNT = 18;
    const WB_OTHER = 0;
    const WB_ALETTER = 1;
    const WB_FORMAT = 2;
    const WB_KATAKANA = 3;
    const WB_MIDLETTER = 4;
    const WB_MIDNUM = 5;
    const WB_NUMERIC = 6;
    const WB_EXTENDNUMLET = 7;
    const WB_CR = 8;
    const WB_EXTEND = 9;
    const WB_LF = 10;
    const WB_MIDNUMLET = 11;
    const WB_NEWLINE = 12;
    const WB_REGIONAL_INDICATOR = 13;
    const WB_HEBREW_LETTER = 14;
    const WB_SINGLE_QUOTE = 15;
    const WB_DOUBLE_QUOTE = 16;
    const WB_COUNT = 23;
    const SB_OTHER = 0;
    const SB_ATERM = 1;
    const SB_CLOSE = 2;
    const SB_FORMAT = 3;
    const SB_LOWER = 4;
    const SB_NUMERIC = 5;
    const SB_OLETTER = 6;
    const SB_SEP = 7;
    const SB_SP = 8;
    const SB_STERM = 9;
    const SB_UPPER = 10;
    const SB_CR = 11;
    const SB_EXTEND = 12;
    const SB_LF = 13;
    const SB_SCONTINUE = 14;
    const SB_COUNT = 15;
    const LB_UNKNOWN = 0;
    const LB_AMBIGUOUS = 1;
    const LB_ALPHABETIC = 2;
    const LB_BREAK_BOTH = 3;
    const LB_BREAK_AFTER = 4;
    const LB_BREAK_BEFORE = 5;
    const LB_MANDATORY_BREAK = 6;
    const LB_CONTINGENT_BREAK = 7;
    const LB_CLOSE_PUNCTUATION = 8;
    const LB_COMBINING_MARK = 9;
    const LB_CARRIAGE_RETURN = 10;
    const LB_EXCLAMATION = 11;
    const LB_GLUE = 12;
    const LB_HYPHEN = 13;
    const LB_IDEOGRAPHIC = 14;
    const LB_INSEPARABLE = 15;
    const LB_INSEPERABLE = 15;
    const LB_INFIX_NUMERIC = 16;
    const LB_LINE_FEED = 17;
    const LB_NONSTARTER = 18;
    const LB_NUMERIC = 19;
    const LB_OPEN_PUNCTUATION = 20;
    const LB_POSTFIX_NUMERIC = 21;
    const LB_PREFIX_NUMERIC = 22;
    const LB_QUOTATION = 23;
    const LB_COMPLEX_CONTEXT = 24;
    const LB_SURROGATE = 25;
    const LB_SPACE = 26;
    const LB_BREAK_SYMBOLS = 27;
    const LB_ZWSPACE = 28;
    const LB_NEXT_LINE = 29;
    const LB_WORD_JOINER = 30;
    const LB_H2 = 31;
    const LB_H3 = 32;
    const LB_JL = 33;
    const LB_JT = 34;
    const LB_JV = 35;
    const LB_CLOSE_PARENTHESIS = 36;
    const LB_CONDITIONAL_JAPANESE_STARTER = 37;
    const LB_HEBREW_LETTER = 38;
    const LB_REGIONAL_INDICATOR = 39;
    const LB_COUNT = 43;
    const NT_NONE = 0;
    const NT_DECIMAL = 1;
    const NT_DIGIT = 2;
    const NT_NUMERIC = 3;
    const NT_COUNT = 4;
    const HST_NOT_APPLICABLE = 0;
    const HST_LEADING_JAMO = 1;
    const HST_VOWEL_JAMO = 2;
    const HST_TRAILING_JAMO = 3;
    const HST_LV_SYLLABLE = 4;
    const HST_LVT_SYLLABLE = 5;
    const HST_COUNT = 6;
    const FOLD_CASE_DEFAULT = 0;
    const FOLD_CASE_EXCLUDE_SPECIAL_I = 1;

    // methods
    public static function hasBinaryProperty(int|string $codepoint, int $property) : ?bool {}
    public static function charAge(int|string $codepoint) : ?array {}
    public static function charDigitValue(int|string $codepoint) : ?int {}
    public static function charDirection(int|string $codepoint) : ?int {}
    public static function charFromName(string $name, int $type = \IntlChar::UNICODE_CHAR_NAME) : ?int {}
    public static function charMirror(int|string $codepoint) : int|null|string {}
    public static function charName(int|string $codepoint, int $type = \IntlChar::UNICODE_CHAR_NAME) : ?string {}
    public static function charType(int|string $codepoint) : ?int {}
    public static function chr(int|string $codepoint) : ?string {}
    public static function digit(int|string $codepoint, int $base = 10) : false|int|null {}
    public static function enumCharNames(int|string $start, int|string $end, callable $callback, int $type = \IntlChar::UNICODE_CHAR_NAME) : ?bool {}
    public static function enumCharTypes(callable $callback) : void {}
    public static function foldCase(int|string $codepoint, int $options = \IntlChar::FOLD_CASE_DEFAULT) : int|null|string {}
    public static function forDigit(int $digit, int $base = 10) : int {}
    public static function getBidiPairedBracket(int|string $codepoint) : int|null|string {}
    public static function getBlockCode(int|string $codepoint) : ?int {}
    public static function getCombiningClass(int|string $codepoint) : ?int {}
    public static function getFC_NFKC_Closure(int|string $codepoint) : false|null|string {}
    public static function getIntPropertyMaxValue(int $property) : int {}
    public static function getIntPropertyMinValue(int $property) : int {}
    public static function getIntPropertyValue(int|string $codepoint, int $property) : ?int {}
    public static function getNumericValue(int|string $codepoint) : ?float {}
    public static function getPropertyEnum(string $alias) : int {}
    public static function getPropertyName(int $property, int $type = \IntlChar::LONG_PROPERTY_NAME) : false|string {}
    public static function getPropertyValueEnum(int $property, string $name) : int {}
    public static function getPropertyValueName(int $property, int $value, int $type = \IntlChar::LONG_PROPERTY_NAME) : false|string {}
    public static function getUnicodeVersion() : array {}
    public static function isalnum(int|string $codepoint) : ?bool {}
    public static function isalpha(int|string $codepoint) : ?bool {}
    public static function isbase(int|string $codepoint) : ?bool {}
    public static function isblank(int|string $codepoint) : ?bool {}
    public static function iscntrl(int|string $codepoint) : ?bool {}
    public static function isdefined(int|string $codepoint) : ?bool {}
    public static function isdigit(int|string $codepoint) : ?bool {}
    public static function isgraph(int|string $codepoint) : ?bool {}
    public static function isIDIgnorable(int|string $codepoint) : ?bool {}
    public static function isIDPart(int|string $codepoint) : ?bool {}
    public static function isIDStart(int|string $codepoint) : ?bool {}
    public static function isISOControl(int|string $codepoint) : ?bool {}
    public static function isJavaIDPart(int|string $codepoint) : ?bool {}
    public static function isJavaIDStart(int|string $codepoint) : ?bool {}
    public static function isJavaSpaceChar(int|string $codepoint) : ?bool {}
    public static function islower(int|string $codepoint) : ?bool {}
    public static function isMirrored(int|string $codepoint) : ?bool {}
    public static function isprint(int|string $codepoint) : ?bool {}
    public static function ispunct(int|string $codepoint) : ?bool {}
    public static function isspace(int|string $codepoint) : ?bool {}
    public static function istitle(int|string $codepoint) : ?bool {}
    public static function isUAlphabetic(int|string $codepoint) : ?bool {}
    public static function isULowercase(int|string $codepoint) : ?bool {}
    public static function isupper(int|string $codepoint) : ?bool {}
    public static function isUUppercase(int|string $codepoint) : ?bool {}
    public static function isUWhiteSpace(int|string $codepoint) : ?bool {}
    public static function isWhitespace(int|string $codepoint) : ?bool {}
    public static function isxdigit(int|string $codepoint) : ?bool {}
    public static function ord(int|string $character) : ?int {}
    public static function tolower(int|string $codepoint) : int|null|string {}
    public static function totitle(int|string $codepoint) : int|null|string {}
    public static function toupper(int|string $codepoint) : int|null|string {}
}

class IntlCodePointBreakIterator extends \IntlBreakIterator {

    // constants
    const DONE = -1;
    const WORD_NONE = 0;
    const WORD_NONE_LIMIT = 100;
    const WORD_NUMBER = 100;
    const WORD_NUMBER_LIMIT = 200;
    const WORD_LETTER = 200;
    const WORD_LETTER_LIMIT = 300;
    const WORD_KANA = 300;
    const WORD_KANA_LIMIT = 400;
    const WORD_IDEO = 400;
    const WORD_IDEO_LIMIT = 500;
    const LINE_SOFT = 0;
    const LINE_SOFT_LIMIT = 100;
    const LINE_HARD = 100;
    const LINE_HARD_LIMIT = 200;
    const SENTENCE_TERM = 0;
    const SENTENCE_TERM_LIMIT = 100;
    const SENTENCE_SEP = 100;
    const SENTENCE_SEP_LIMIT = 200;

    // methods
    public function getLastCodePoint() : int {}
}

class IntlDateFormatter {

    // constants
    const FULL = 0;
    const LONG = 1;
    const MEDIUM = 2;
    const SHORT = 3;
    const NONE = -1;
    const RELATIVE_FULL = 128;
    const RELATIVE_LONG = 129;
    const RELATIVE_MEDIUM = 130;
    const RELATIVE_SHORT = 131;
    const GREGORIAN = 1;
    const TRADITIONAL = 0;

    // methods
    public function __construct(?string $locale, int $dateType = \IntlDateFormatter::FULL, int $timeType = \IntlDateFormatter::FULL, $timezone = null, $calendar = null, ?string $pattern = null) {}
    public static function create(?string $locale, int $dateType = \IntlDateFormatter::FULL, int $timeType = \IntlDateFormatter::FULL, $timezone = null, \IntlCalendar|int|null $calendar = null, ?string $pattern = null) : ?\IntlDateFormatter {}
    public function getDateType() : false|int {}
    public function getTimeType() : false|int {}
    public function getCalendar() : false|int {}
    public function setCalendar(\IntlCalendar|int|null $calendar) : bool {}
    public function getTimeZoneId() : false|string {}
    public function getCalendarObject() : \IntlCalendar|false|null {}
    public function getTimeZone() : \IntlTimeZone|false {}
    public function setTimeZone($timezone) : ?bool {}
    public function setPattern(string $pattern) : bool {}
    public function getPattern() : false|string {}
    public function getLocale(int $type = \ULOC_ACTUAL_LOCALE) : false|string {}
    public function setLenient(bool $lenient) : void {}
    public function isLenient() : bool {}
    public function format($datetime) : false|string {}
    public static function formatObject($datetime, $format = null, ?string $locale = null) : false|string {}
    public function parse(string $string, &$offset = null) : false|float|int {}
    public function localtime(string $string, &$offset = null) : array|false {}
    public function getErrorCode() : int {}
    public function getErrorMessage() : string {}
}

class IntlDatePatternGenerator {

    // methods
    public function __construct(?string $locale = null) {}
    public static function create(?string $locale = null) : ?\IntlDatePatternGenerator {}
    public function getBestPattern(string $skeleton) : false|string {}
}

class IntlException extends \Exception {

    // properties
    protected $message;
    protected $code;
    protected $file;
    protected $line;
}

class IntlGregorianCalendar extends \IntlCalendar {

    // constants
    const FIELD_ERA = 0;
    const FIELD_YEAR = 1;
    const FIELD_MONTH = 2;
    const FIELD_WEEK_OF_YEAR = 3;
    const FIELD_WEEK_OF_MONTH = 4;
    const FIELD_DATE = 5;
    const FIELD_DAY_OF_YEAR = 6;
    const FIELD_DAY_OF_WEEK = 7;
    const FIELD_DAY_OF_WEEK_IN_MONTH = 8;
    const FIELD_AM_PM = 9;
    const FIELD_HOUR = 10;
    const FIELD_HOUR_OF_DAY = 11;
    const FIELD_MINUTE = 12;
    const FIELD_SECOND = 13;
    const FIELD_MILLISECOND = 14;
    const FIELD_ZONE_OFFSET = 15;
    const FIELD_DST_OFFSET = 16;
    const FIELD_YEAR_WOY = 17;
    const FIELD_DOW_LOCAL = 18;
    const FIELD_EXTENDED_YEAR = 19;
    const FIELD_JULIAN_DAY = 20;
    const FIELD_MILLISECONDS_IN_DAY = 21;
    const FIELD_IS_LEAP_MONTH = 22;
    const FIELD_FIELD_COUNT = 23;
    const FIELD_DAY_OF_MONTH = 5;
    const DOW_SUNDAY = 1;
    const DOW_MONDAY = 2;
    const DOW_TUESDAY = 3;
    const DOW_WEDNESDAY = 4;
    const DOW_THURSDAY = 5;
    const DOW_FRIDAY = 6;
    const DOW_SATURDAY = 7;
    const DOW_TYPE_WEEKDAY = 0;
    const DOW_TYPE_WEEKEND = 1;
    const DOW_TYPE_WEEKEND_OFFSET = 2;
    const DOW_TYPE_WEEKEND_CEASE = 3;
    const WALLTIME_FIRST = 1;
    const WALLTIME_LAST = 0;
    const WALLTIME_NEXT_VALID = 2;

    // methods
    public function __construct($timezoneOrYear = null, $localeOrMonth = null, $day = null, $hour = null, $minute = null, $second = null) {}
    public function setGregorianChange(float $timestamp) : bool {}
    public function getGregorianChange() : float {}
    public function isLeapYear(int $year) : bool {}
}

class IntlIterator implements \Iterator, \Traversable {

    // methods
    public function current() : mixed {}
    public function key() : mixed {}
    public function next() : void {}
    public function rewind() : void {}
    public function valid() : bool {}
}

class IntlPartsIterator extends \IntlIterator {

    // constants
    const KEY_SEQUENTIAL = 0;
    const KEY_LEFT = 1;
    const KEY_RIGHT = 2;

    // methods
    public function getBreakIterator() : \IntlBreakIterator {}
    public function getRuleStatus() : int {}
}

class IntlRuleBasedBreakIterator extends \IntlBreakIterator {

    // constants
    const DONE = -1;
    const WORD_NONE = 0;
    const WORD_NONE_LIMIT = 100;
    const WORD_NUMBER = 100;
    const WORD_NUMBER_LIMIT = 200;
    const WORD_LETTER = 200;
    const WORD_LETTER_LIMIT = 300;
    const WORD_KANA = 300;
    const WORD_KANA_LIMIT = 400;
    const WORD_IDEO = 400;
    const WORD_IDEO_LIMIT = 500;
    const LINE_SOFT = 0;
    const LINE_SOFT_LIMIT = 100;
    const LINE_HARD = 100;
    const LINE_HARD_LIMIT = 200;
    const SENTENCE_TERM = 0;
    const SENTENCE_TERM_LIMIT = 100;
    const SENTENCE_SEP = 100;
    const SENTENCE_SEP_LIMIT = 200;

    // methods
    public function __construct(string $rules, bool $compiled = false) {}
    public function getBinaryRules() : false|string {}
    public function getRules() : false|string {}
    public function getRuleStatus() : int {}
    public function getRuleStatusVec() : array|false {}
}

class IntlTimeZone {

    // constants
    const DISPLAY_SHORT = 1;
    const DISPLAY_LONG = 2;
    const DISPLAY_SHORT_GENERIC = 3;
    const DISPLAY_LONG_GENERIC = 4;
    const DISPLAY_SHORT_GMT = 5;
    const DISPLAY_LONG_GMT = 6;
    const DISPLAY_SHORT_COMMONLY_USED = 7;
    const DISPLAY_GENERIC_LOCATION = 8;
    const TYPE_ANY = 0;
    const TYPE_CANONICAL = 1;
    const TYPE_CANONICAL_LOCATION = 2;

    // methods
    private function __construct() {}
    public static function countEquivalentIDs(string $timezoneId) : false|int {}
    public static function createDefault() : \IntlTimeZone {}
    public static function createEnumeration($countryOrRawOffset = null) : \IntlIterator|false {}
    public static function createTimeZone(string $timezoneId) : ?\IntlTimeZone {}
    public static function createTimeZoneIDEnumeration(int $type, ?string $region = null, ?int $rawOffset = null) : \IntlIterator|false {}
    public static function fromDateTimeZone(\DateTimeZone $timezone) : ?\IntlTimeZone {}
    public static function getCanonicalID(string $timezoneId, &$isSystemId = null) : false|string {}
    public function getDisplayName(bool $dst = false, int $style = \IntlTimeZone::DISPLAY_LONG, ?string $locale = null) : false|string {}
    public function getDSTSavings() : int {}
    public static function getEquivalentID(string $timezoneId, int $offset) : false|string {}
    public function getErrorCode() : false|int {}
    public function getErrorMessage() : false|string {}
    public static function getGMT() : \IntlTimeZone {}
    public function getID() : false|string {}
    public function getOffset(float $timestamp, bool $local, &$rawOffset, &$dstOffset) : bool {}
    public function getRawOffset() : int {}
    public static function getRegion(string $timezoneId) : false|string {}
    public static function getTZDataVersion() : false|string {}
    public static function getUnknown() : \IntlTimeZone {}
    public static function getWindowsID(string $timezoneId) : false|string {}
    public static function getIDForWindowsID(string $timezoneId, ?string $region = null) : false|string {}
    public function hasSameRules(\IntlTimeZone $other) : bool {}
    public function toDateTimeZone() : \DateTimeZone|false {}
    public function useDaylightTime() : bool {}
}

class Locale {

    // constants
    const ACTUAL_LOCALE = 0;
    const VALID_LOCALE = 1;
    const DEFAULT_LOCALE = null;
    const LANG_TAG = 'language';
    const EXTLANG_TAG = 'extlang';
    const SCRIPT_TAG = 'script';
    const REGION_TAG = 'region';
    const VARIANT_TAG = 'variant';
    const GRANDFATHERED_LANG_TAG = 'grandfathered';
    const PRIVATE_TAG = 'private';

    // properties
    public $name;

    // methods
    public static function getDefault() : string {}
    public static function setDefault(string $locale) {}
    public static function getPrimaryLanguage(string $locale) : ?string {}
    public static function getScript(string $locale) : ?string {}
    public static function getRegion(string $locale) : ?string {}
    public static function getKeywords(string $locale) : array|false|null {}
    public static function getDisplayScript(string $locale, ?string $displayLocale = null) : false|string {}
    public static function getDisplayRegion(string $locale, ?string $displayLocale = null) : false|string {}
    public static function getDisplayName(string $locale, ?string $displayLocale = null) : false|string {}
    public static function getDisplayLanguage(string $locale, ?string $displayLocale = null) : false|string {}
    public static function getDisplayVariant(string $locale, ?string $displayLocale = null) : false|string {}
    public static function composeLocale(array $subtags) : false|string {}
    public static function parseLocale(string $locale) : ?array {}
    public static function getAllVariants(string $locale) : ?array {}
    public static function filterMatches(string $languageTag, string $locale, bool $canonicalize = false) : ?bool {}
    public static function lookup(array $languageTag, string $locale, bool $canonicalize = false, ?string $defaultLocale = null) : ?string {}
    public static function canonicalize(string $locale) : ?string {}
    public static function acceptFromHttp(string $header) : false|string {}
}

class MessageFormatter {

    // methods
    public function __construct(string $locale, string $pattern) {}
    public static function create(string $locale, string $pattern) : ?\MessageFormatter {}
    public function format(array $values) : false|string {}
    public static function formatMessage(string $locale, string $pattern, array $values) : false|string {}
    public function parse(string $string) : array|false {}
    public static function parseMessage(string $locale, string $pattern, string $message) : array|false {}
    public function setPattern(string $pattern) : bool {}
    public function getPattern() : false|string {}
    public function getLocale() : string {}
    public function getErrorCode() : int {}
    public function getErrorMessage() : string {}
}

class Normalizer {

    // constants
    const FORM_D = 4;
    const NFD = 4;
    const FORM_KD = 8;
    const NFKD = 8;
    const FORM_C = 16;
    const NFC = 16;
    const FORM_KC = 32;
    const NFKC = 32;
    const FORM_KC_CF = 48;
    const NFKC_CF = 48;

    // properties
    public $name;

    // methods
    public static function normalize(string $string, int $form = \Normalizer::FORM_C) : false|string {}
    public static function isNormalized(string $string, int $form = \Normalizer::FORM_C) : bool {}
    public static function getRawDecomposition(string $string, int $form = \Normalizer::FORM_C) : ?string {}
}

class NumberFormatter {

    // constants
    const PATTERN_DECIMAL = 0;
    const DECIMAL = 1;
    const CURRENCY = 2;
    const PERCENT = 3;
    const SCIENTIFIC = 4;
    const SPELLOUT = 5;
    const ORDINAL = 6;
    const DURATION = 7;
    const PATTERN_RULEBASED = 9;
    const IGNORE = 0;
    const CURRENCY_ACCOUNTING = 12;
    const DEFAULT_STYLE = 1;
    const ROUND_CEILING = 0;
    const ROUND_FLOOR = 1;
    const ROUND_DOWN = 2;
    const ROUND_UP = 3;
    const ROUND_HALFEVEN = 4;
    const ROUND_HALFDOWN = 5;
    const ROUND_HALFUP = 6;
    const PAD_BEFORE_PREFIX = 0;
    const PAD_AFTER_PREFIX = 1;
    const PAD_BEFORE_SUFFIX = 2;
    const PAD_AFTER_SUFFIX = 3;
    const PARSE_INT_ONLY = 0;
    const GROUPING_USED = 1;
    const DECIMAL_ALWAYS_SHOWN = 2;
    const MAX_INTEGER_DIGITS = 3;
    const MIN_INTEGER_DIGITS = 4;
    const INTEGER_DIGITS = 5;
    const MAX_FRACTION_DIGITS = 6;
    const MIN_FRACTION_DIGITS = 7;
    const FRACTION_DIGITS = 8;
    const MULTIPLIER = 9;
    const GROUPING_SIZE = 10;
    const ROUNDING_MODE = 11;
    const ROUNDING_INCREMENT = 12;
    const FORMAT_WIDTH = 13;
    const PADDING_POSITION = 14;
    const SECONDARY_GROUPING_SIZE = 15;
    const SIGNIFICANT_DIGITS_USED = 16;
    const MIN_SIGNIFICANT_DIGITS = 17;
    const MAX_SIGNIFICANT_DIGITS = 18;
    const LENIENT_PARSE = 19;
    const POSITIVE_PREFIX = 0;
    const POSITIVE_SUFFIX = 1;
    const NEGATIVE_PREFIX = 2;
    const NEGATIVE_SUFFIX = 3;
    const PADDING_CHARACTER = 4;
    const CURRENCY_CODE = 5;
    const DEFAULT_RULESET = 6;
    const PUBLIC_RULESETS = 7;
    const DECIMAL_SEPARATOR_SYMBOL = 0;
    const GROUPING_SEPARATOR_SYMBOL = 1;
    const PATTERN_SEPARATOR_SYMBOL = 2;
    const PERCENT_SYMBOL = 3;
    const ZERO_DIGIT_SYMBOL = 4;
    const DIGIT_SYMBOL = 5;
    const MINUS_SIGN_SYMBOL = 6;
    const PLUS_SIGN_SYMBOL = 7;
    const CURRENCY_SYMBOL = 8;
    const INTL_CURRENCY_SYMBOL = 9;
    const MONETARY_SEPARATOR_SYMBOL = 10;
    const EXPONENTIAL_SYMBOL = 11;
    const PERMILL_SYMBOL = 12;
    const PAD_ESCAPE_SYMBOL = 13;
    const INFINITY_SYMBOL = 14;
    const NAN_SYMBOL = 15;
    const SIGNIFICANT_DIGIT_SYMBOL = 16;
    const MONETARY_GROUPING_SEPARATOR_SYMBOL = 17;
    const TYPE_DEFAULT = 0;
    const TYPE_INT32 = 1;
    const TYPE_INT64 = 2;
    const TYPE_DOUBLE = 3;
    const TYPE_CURRENCY = 4;

    // properties
    public $name;

    // methods
    public function __construct(string $locale, int $style, ?string $pattern = null) {}
    public static function create(string $locale, int $style, ?string $pattern = null) : ?\NumberFormatter {}
    public function format(float|int $num, int $type = \NumberFormatter::TYPE_DEFAULT) : false|string {}
    public function parse(string $string, int $type = \NumberFormatter::TYPE_DOUBLE, &$offset = null) : false|float|int {}
    public function formatCurrency(float $amount, string $currency) : false|string {}
    public function parseCurrency(string $string, &$currency, &$offset = null) : false|float {}
    public function setAttribute(int $attribute, float|int $value) : bool {}
    public function getAttribute(int $attribute) : false|float|int {}
    public function setTextAttribute(int $attribute, string $value) : bool {}
    public function getTextAttribute(int $attribute) : false|string {}
    public function setSymbol(int $symbol, string $value) : bool {}
    public function getSymbol(int $symbol) : false|string {}
    public function setPattern(string $pattern) : bool {}
    public function getPattern() : false|string {}
    public function getLocale(int $type = \ULOC_ACTUAL_LOCALE) : false|string {}
    public function getErrorCode() : int {}
    public function getErrorMessage() : string {}
}

class ResourceBundle implements \IteratorAggregate, \Traversable, \Countable {

    // methods
    public function __construct(?string $locale, ?string $bundle, bool $fallback = true) {}
    public static function create(?string $locale, ?string $bundle, bool $fallback = true) : ?\ResourceBundle {}
    public function get($index, bool $fallback = true) : mixed {}
    public function count() : int {}
    public static function getLocales(string $bundle) : array|false {}
    public function getErrorCode() : int {}
    public function getErrorMessage() : string {}
    public function getIterator() : \Iterator {}
}

class Spoofchecker {

    // constants
    const SINGLE_SCRIPT_CONFUSABLE = 1;
    const MIXED_SCRIPT_CONFUSABLE = 2;
    const WHOLE_SCRIPT_CONFUSABLE = 4;
    const ANY_CASE = 8;
    const SINGLE_SCRIPT = 16;
    const INVISIBLE = 32;
    const CHAR_LIMIT = 64;
    const ASCII = 268435456;
    const HIGHLY_RESTRICTIVE = 805306368;
    const MODERATELY_RESTRICTIVE = 1073741824;
    const MINIMALLY_RESTRICTIVE = 1342177280;
    const UNRESTRICTIVE = 1610612736;
    const SINGLE_SCRIPT_RESTRICTIVE = 536870912;

    // methods
    public function __construct() {}
    public function isSuspicious(string $string, &$errorCode = null) : bool {}
    public function areConfusable(string $string1, string $string2, &$errorCode = null) : bool {}
    public function setAllowedLocales(string $locales) : void {}
    public function setChecks(int $checks) : void {}
    public function setRestrictionLevel(int $level) : void {}
}

class Transliterator {

    // constants
    const FORWARD = 0;
    const REVERSE = 1;

    // properties
    public $id;

    // methods
    final private function __construct() {}
    public static function create(string $id, int $direction = \Transliterator::FORWARD) : ?\Transliterator {}
    public static function createFromRules(string $rules, int $direction = \Transliterator::FORWARD) : ?\Transliterator {}
    public function createInverse() : ?\Transliterator {}
    public static function listIDs() : array|false {}
    public function transliterate(string $string, int $start = 0, int $end = -1) : false|string {}
    public function getErrorCode() : false|int {}
    public function getErrorMessage() : false|string {}
}

class UConverter {

    // constants
    const REASON_UNASSIGNED = 0;
    const REASON_ILLEGAL = 1;
    const REASON_IRREGULAR = 2;
    const REASON_RESET = 3;
    const REASON_CLOSE = 4;
    const REASON_CLONE = 5;
    const UNSUPPORTED_CONVERTER = -1;
    const SBCS = 0;
    const DBCS = 1;
    const MBCS = 2;
    const LATIN_1 = 3;
    const UTF8 = 4;
    const UTF16_BigEndian = 5;
    const UTF16_LittleEndian = 6;
    const UTF32_BigEndian = 7;
    const UTF32_LittleEndian = 8;
    const EBCDIC_STATEFUL = 9;
    const ISO_2022 = 10;
    const LMBCS_1 = 11;
    const LMBCS_2 = 12;
    const LMBCS_3 = 13;
    const LMBCS_4 = 14;
    const LMBCS_5 = 15;
    const LMBCS_6 = 16;
    const LMBCS_8 = 17;
    const LMBCS_11 = 18;
    const LMBCS_16 = 19;
    const LMBCS_17 = 20;
    const LMBCS_18 = 21;
    const LMBCS_19 = 22;
    const LMBCS_LAST = 22;
    const HZ = 23;
    const SCSU = 24;
    const ISCII = 25;
    const US_ASCII = 26;
    const UTF7 = 27;
    const BOCU1 = 28;
    const UTF16 = 29;
    const UTF32 = 30;
    const CESU8 = 31;
    const IMAP_MAILBOX = 32;

    // methods
    public function __construct(?string $destination_encoding = null, ?string $source_encoding = null) {}
    public function convert(string $str, bool $reverse = false) : false|string {}
    public function fromUCallback(int $reason, array $source, int $codePoint, &$error) : array|int|null|string {}
    public static function getAliases(string $name) : array|false|null {}
    public static function getAvailable() : array {}
    public function getDestinationEncoding() : false|null|string {}
    public function getDestinationType() : false|int|null {}
    public function getErrorCode() : int {}
    public function getErrorMessage() : ?string {}
    public function getSourceEncoding() : false|null|string {}
    public function getSourceType() : false|int|null {}
    public static function getStandards() : ?array {}
    public function getSubstChars() : false|null|string {}
    public static function reasonText(int $reason) : string {}
    public function setDestinationEncoding(string $encoding) : bool {}
    public function setSourceEncoding(string $encoding) : bool {}
    public function setSubstChars(string $chars) : bool {}
    public function toUCallback(int $reason, string $source, string $codeUnits, &$error) : array|int|null|string {}
    public static function transcode(string $str, string $toEncoding, string $fromEncoding, ?array $options = null) : false|string {}
}

function collator_asort(\Collator $object, array &$array, int $flags = \Collator::SORT_REGULAR) : bool {}
function collator_compare(\Collator $object, string $string1, string $string2) : false|int {}
function collator_create(string $locale) : ?\Collator {}
function collator_get_attribute(\Collator $object, int $attribute) : false|int {}
function collator_get_error_code(\Collator $object) : false|int {}
function collator_get_error_message(\Collator $object) : false|string {}
function collator_get_locale(\Collator $object, int $type) : false|string {}
function collator_get_sort_key(\Collator $object, string $string) : false|string {}
function collator_get_strength(\Collator $object) : int {}
function collator_set_attribute(\Collator $object, int $attribute, int $value) : bool {}
function collator_set_strength(\Collator $object, int $strength) : bool {}
function collator_sort(\Collator $object, array &$array, int $flags = \Collator::SORT_REGULAR) : bool {}
function collator_sort_with_sort_keys(\Collator $object, array &$array) : bool {}
function datefmt_create(?string $locale, int $dateType = \IntlDateFormatter::FULL, int $timeType = \IntlDateFormatter::FULL, $timezone = null, \IntlCalendar|int|null $calendar = null, ?string $pattern = null) : ?\IntlDateFormatter {}
function datefmt_format(\IntlDateFormatter $formatter, $datetime) : false|string {}
function datefmt_format_object($datetime, $format = null, ?string $locale = null) : false|string {}
function datefmt_get_calendar(\IntlDateFormatter $formatter) : false|int {}
function datefmt_get_calendar_object(\IntlDateFormatter $formatter) : \IntlCalendar|false|null {}
function datefmt_get_datetype(\IntlDateFormatter $formatter) : false|int {}
function datefmt_get_error_code(\IntlDateFormatter $formatter) : int {}
function datefmt_get_error_message(\IntlDateFormatter $formatter) : string {}
function datefmt_get_locale(\IntlDateFormatter $formatter, int $type = \ULOC_ACTUAL_LOCALE) : false|string {}
function datefmt_get_pattern(\IntlDateFormatter $formatter) : false|string {}
function datefmt_get_timetype(\IntlDateFormatter $formatter) : false|int {}
function datefmt_get_timezone(\IntlDateFormatter $formatter) : \IntlTimeZone|false {}
function datefmt_get_timezone_id(\IntlDateFormatter $formatter) : false|string {}
function datefmt_is_lenient(\IntlDateFormatter $formatter) : bool {}
function datefmt_localtime(\IntlDateFormatter $formatter, string $string, &$offset = null) : array|false {}
function datefmt_parse(\IntlDateFormatter $formatter, string $string, &$offset = null) : false|float|int {}
function datefmt_set_calendar(\IntlDateFormatter $formatter, \IntlCalendar|int|null $calendar) : bool {}
function datefmt_set_lenient(\IntlDateFormatter $formatter, bool $lenient) : void {}
function datefmt_set_pattern(\IntlDateFormatter $formatter, string $pattern) : bool {}
function datefmt_set_timezone(\IntlDateFormatter $formatter, $timezone) : ?bool {}
function grapheme_extract(string $haystack, int $size, int $type = \GRAPHEME_EXTR_COUNT, int $offset = 0, &$next = null) : false|string {}
function grapheme_stripos(string $haystack, string $needle, int $offset = 0) : false|int {}
function grapheme_stristr(string $haystack, string $needle, bool $beforeNeedle = false) : false|string {}
function grapheme_strlen(string $string) : false|int|null {}
function grapheme_strpos(string $haystack, string $needle, int $offset = 0) : false|int {}
function grapheme_strripos(string $haystack, string $needle, int $offset = 0) : false|int {}
function grapheme_strrpos(string $haystack, string $needle, int $offset = 0) : false|int {}
function grapheme_strstr(string $haystack, string $needle, bool $beforeNeedle = false) : false|string {}
function grapheme_substr(string $string, int $offset, ?int $length = null) : false|string {}
function idn_to_ascii(string $domain, int $flags = \IDNA_DEFAULT, int $variant = \INTL_IDNA_VARIANT_UTS46, &$idna_info = null) : false|string {}
function idn_to_utf8(string $domain, int $flags = \IDNA_DEFAULT, int $variant = \INTL_IDNA_VARIANT_UTS46, &$idna_info = null) : false|string {}
function intl_error_name(int $errorCode) : string {}
function intl_get_error_code() : int {}
function intl_get_error_message() : string {}
function intl_is_failure(int $errorCode) : bool {}
function intlcal_add(\IntlCalendar $calendar, int $field, int $value) : bool {}
function intlcal_after(\IntlCalendar $calendar, \IntlCalendar $other) : bool {}
function intlcal_before(\IntlCalendar $calendar, \IntlCalendar $other) : bool {}
function intlcal_clear(\IntlCalendar $calendar, ?int $field = null) : bool {}
function intlcal_create_instance($timezone = null, ?string $locale = null) : ?\IntlCalendar {}
function intlcal_equals(\IntlCalendar $calendar, \IntlCalendar $other) : bool {}
function intlcal_field_difference(\IntlCalendar $calendar, float $timestamp, int $field) : false|int {}
function intlcal_from_date_time(\DateTime|string $datetime, ?string $locale = null) : ?\IntlCalendar {}
function intlcal_get(\IntlCalendar $calendar, int $field) : false|int {}
function intlcal_get_actual_maximum(\IntlCalendar $calendar, int $field) : false|int {}
function intlcal_get_actual_minimum(\IntlCalendar $calendar, int $field) : false|int {}
function intlcal_get_available_locales() : array {}
function intlcal_get_day_of_week_type(\IntlCalendar $calendar, int $dayOfWeek) : false|int {}
function intlcal_get_error_code(\IntlCalendar $calendar) : false|int {}
function intlcal_get_error_message(\IntlCalendar $calendar) : false|string {}
function intlcal_get_first_day_of_week(\IntlCalendar $calendar) : false|int {}
function intlcal_get_greatest_minimum(\IntlCalendar $calendar, int $field) : false|int {}
function intlcal_get_keyword_values_for_locale(string $keyword, string $locale, bool $onlyCommon) : \IntlIterator|false {}
function intlcal_get_least_maximum(\IntlCalendar $calendar, int $field) : false|int {}
function intlcal_get_locale(\IntlCalendar $calendar, int $type) : false|string {}
function intlcal_get_maximum(\IntlCalendar $calendar, int $field) : false|int {}
function intlcal_get_minimal_days_in_first_week(\IntlCalendar $calendar) : false|int {}
function intlcal_get_minimum(\IntlCalendar $calendar, int $field) : false|int {}
function intlcal_get_now() : float {}
function intlcal_get_repeated_wall_time_option(\IntlCalendar $calendar) : int {}
function intlcal_get_skipped_wall_time_option(\IntlCalendar $calendar) : int {}
function intlcal_get_time(\IntlCalendar $calendar) : false|float {}
function intlcal_get_time_zone(\IntlCalendar $calendar) : \IntlTimeZone|false {}
function intlcal_get_type(\IntlCalendar $calendar) : string {}
function intlcal_get_weekend_transition(\IntlCalendar $calendar, int $dayOfWeek) : false|int {}
function intlcal_in_daylight_time(\IntlCalendar $calendar) : bool {}
function intlcal_is_equivalent_to(\IntlCalendar $calendar, \IntlCalendar $other) : bool {}
function intlcal_is_lenient(\IntlCalendar $calendar) : bool {}
function intlcal_is_set(\IntlCalendar $calendar, int $field) : bool {}
function intlcal_is_weekend(\IntlCalendar $calendar, ?float $timestamp = null) : bool {}
function intlcal_roll(\IntlCalendar $calendar, int $field, $value) : bool {}
function intlcal_set(\IntlCalendar $calendar, int $year, int $month, int $dayOfMonth = unknown, int $hour = unknown, int $minute = unknown, int $second = unknown) : bool {}
function intlcal_set_first_day_of_week(\IntlCalendar $calendar, int $dayOfWeek) : bool {}
function intlcal_set_lenient(\IntlCalendar $calendar, bool $lenient) : bool {}
function intlcal_set_minimal_days_in_first_week(\IntlCalendar $calendar, int $days) : bool {}
function intlcal_set_repeated_wall_time_option(\IntlCalendar $calendar, int $option) : bool {}
function intlcal_set_skipped_wall_time_option(\IntlCalendar $calendar, int $option) : bool {}
function intlcal_set_time(\IntlCalendar $calendar, float $timestamp) : bool {}
function intlcal_set_time_zone(\IntlCalendar $calendar, $timezone) : bool {}
function intlcal_to_date_time(\IntlCalendar $calendar) : \DateTime|false {}
function intlgregcal_create_instance($timezoneOrYear = null, $localeOrMonth = null, $day = null, $hour = null, $minute = null, $second = null) : ?\IntlGregorianCalendar {}
function intlgregcal_get_gregorian_change(\IntlGregorianCalendar $calendar) : float {}
function intlgregcal_is_leap_year(\IntlGregorianCalendar $calendar, int $year) : bool {}
function intlgregcal_set_gregorian_change(\IntlGregorianCalendar $calendar, float $timestamp) : bool {}
function intltz_count_equivalent_ids(string $timezoneId) : false|int {}
function intltz_create_default() : \IntlTimeZone {}
function intltz_create_enumeration($countryOrRawOffset = null) : \IntlIterator|false {}
function intltz_create_time_zone(string $timezoneId) : ?\IntlTimeZone {}
function intltz_create_time_zone_id_enumeration(int $type, ?string $region = null, ?int $rawOffset = null) : \IntlIterator|false {}
function intltz_from_date_time_zone(\DateTimeZone $timezone) : ?\IntlTimeZone {}
function intltz_get_canonical_id(string $timezoneId, &$isSystemId = null) : false|string {}
function intltz_get_display_name(\IntlTimeZone $timezone, bool $dst = false, int $style = \IntlTimeZone::DISPLAY_LONG, ?string $locale = null) : false|string {}
function intltz_get_dst_savings(\IntlTimeZone $timezone) : int {}
function intltz_get_equivalent_id(string $timezoneId, int $offset) : false|string {}
function intltz_get_error_code(\IntlTimeZone $timezone) : false|int {}
function intltz_get_error_message(\IntlTimeZone $timezone) : false|string {}
function intltz_get_gmt() : \IntlTimeZone {}
function intltz_get_id(\IntlTimeZone $timezone) : false|string {}
function intltz_get_id_for_windows_id(string $timezoneId, ?string $region = null) : false|string {}
function intltz_get_offset(\IntlTimeZone $timezone, float $timestamp, bool $local, &$rawOffset, &$dstOffset) : bool {}
function intltz_get_raw_offset(\IntlTimeZone $timezone) : int {}
function intltz_get_region(string $timezoneId) : false|string {}
function intltz_get_tz_data_version() : false|string {}
function intltz_get_unknown() : \IntlTimeZone {}
function intltz_get_windows_id(string $timezoneId) : false|string {}
function intltz_has_same_rules(\IntlTimeZone $timezone, \IntlTimeZone $other) : bool {}
function intltz_to_date_time_zone(\IntlTimeZone $timezone) : \DateTimeZone|false {}
function intltz_use_daylight_time(\IntlTimeZone $timezone) : bool {}
function locale_accept_from_http(string $header) : false|string {}
function locale_canonicalize(string $locale) : ?string {}
function locale_compose(array $subtags) : false|string {}
function locale_filter_matches(string $languageTag, string $locale, bool $canonicalize = false) : ?bool {}
function locale_get_all_variants(string $locale) : ?array {}
function locale_get_default() : string {}
function locale_get_display_language(string $locale, ?string $displayLocale = null) : false|string {}
function locale_get_display_name(string $locale, ?string $displayLocale = null) : false|string {}
function locale_get_display_region(string $locale, ?string $displayLocale = null) : false|string {}
function locale_get_display_script(string $locale, ?string $displayLocale = null) : false|string {}
function locale_get_display_variant(string $locale, ?string $displayLocale = null) : false|string {}
function locale_get_keywords(string $locale) : array|false|null {}
function locale_get_primary_language(string $locale) : ?string {}
function locale_get_region(string $locale) : ?string {}
function locale_get_script(string $locale) : ?string {}
function locale_lookup(array $languageTag, string $locale, bool $canonicalize = false, ?string $defaultLocale = null) : ?string {}
function locale_parse(string $locale) : ?array {}
function locale_set_default(string $locale) : bool {}
function msgfmt_create(string $locale, string $pattern) : ?\MessageFormatter {}
function msgfmt_format(\MessageFormatter $formatter, array $values) : false|string {}
function msgfmt_format_message(string $locale, string $pattern, array $values) : false|string {}
function msgfmt_get_error_code(\MessageFormatter $formatter) : int {}
function msgfmt_get_error_message(\MessageFormatter $formatter) : string {}
function msgfmt_get_locale(\MessageFormatter $formatter) : string {}
function msgfmt_get_pattern(\MessageFormatter $formatter) : false|string {}
function msgfmt_parse(\MessageFormatter $formatter, string $string) : array|false {}
function msgfmt_parse_message(string $locale, string $pattern, string $message) : array|false {}
function msgfmt_set_pattern(\MessageFormatter $formatter, string $pattern) : bool {}
function normalizer_get_raw_decomposition(string $string, int $form = \Normalizer::FORM_C) : ?string {}
function normalizer_is_normalized(string $string, int $form = \Normalizer::FORM_C) : bool {}
function normalizer_normalize(string $string, int $form = \Normalizer::FORM_C) : false|string {}
function numfmt_create(string $locale, int $style, ?string $pattern = null) : ?\NumberFormatter {}
function numfmt_format(\NumberFormatter $formatter, float|int $num, int $type = \NumberFormatter::TYPE_DEFAULT) : false|string {}
function numfmt_format_currency(\NumberFormatter $formatter, float $amount, string $currency) : false|string {}
function numfmt_get_attribute(\NumberFormatter $formatter, int $attribute) : false|float|int {}
function numfmt_get_error_code(\NumberFormatter $formatter) : int {}
function numfmt_get_error_message(\NumberFormatter $formatter) : string {}
function numfmt_get_locale(\NumberFormatter $formatter, int $type = \ULOC_ACTUAL_LOCALE) : false|string {}
function numfmt_get_pattern(\NumberFormatter $formatter) : false|string {}
function numfmt_get_symbol(\NumberFormatter $formatter, int $symbol) : false|string {}
function numfmt_get_text_attribute(\NumberFormatter $formatter, int $attribute) : false|string {}
function numfmt_parse(\NumberFormatter $formatter, string $string, int $type = \NumberFormatter::TYPE_DOUBLE, &$offset = null) : false|float|int {}
function numfmt_parse_currency(\NumberFormatter $formatter, string $string, &$currency, &$offset = null) : false|float {}
function numfmt_set_attribute(\NumberFormatter $formatter, int $attribute, float|int $value) : bool {}
function numfmt_set_pattern(\NumberFormatter $formatter, string $pattern) : bool {}
function numfmt_set_symbol(\NumberFormatter $formatter, int $symbol, string $value) : bool {}
function numfmt_set_text_attribute(\NumberFormatter $formatter, int $attribute, string $value) : bool {}
function resourcebundle_count(\ResourceBundle $bundle) : int {}
function resourcebundle_create(?string $locale, ?string $bundle, bool $fallback = true) : ?\ResourceBundle {}
function resourcebundle_get(\ResourceBundle $bundle, $index, bool $fallback = true) : mixed {}
function resourcebundle_get_error_code(\ResourceBundle $bundle) : int {}
function resourcebundle_get_error_message(\ResourceBundle $bundle) : string {}
function resourcebundle_locales(string $bundle) : array|false {}
function transliterator_create(string $id, int $direction = \Transliterator::FORWARD) : ?\Transliterator {}
function transliterator_create_from_rules(string $rules, int $direction = \Transliterator::FORWARD) : ?\Transliterator {}
function transliterator_create_inverse(\Transliterator $transliterator) : ?\Transliterator {}
function transliterator_get_error_code(\Transliterator $transliterator) : false|int {}
function transliterator_get_error_message(\Transliterator $transliterator) : false|string {}
function transliterator_list_ids() : array|false {}
function transliterator_transliterate(\Transliterator|string $transliterator, string $string, int $start = 0, int $end = -1) : false|string {}
const GRAPHEME_EXTR_COUNT = 0;
const GRAPHEME_EXTR_MAXBYTES = 1;
const GRAPHEME_EXTR_MAXCHARS = 2;
const IDNA_ALLOW_UNASSIGNED = 1;
const IDNA_CHECK_BIDI = 4;
const IDNA_CHECK_CONTEXTJ = 8;
const IDNA_DEFAULT = 0;
const IDNA_ERROR_BIDI = 2048;
const IDNA_ERROR_CONTEXTJ = 4096;
const IDNA_ERROR_DISALLOWED = 128;
const IDNA_ERROR_DOMAIN_NAME_TOO_LONG = 4;
const IDNA_ERROR_EMPTY_LABEL = 1;
const IDNA_ERROR_HYPHEN_3_4 = 32;
const IDNA_ERROR_INVALID_ACE_LABEL = 1024;
const IDNA_ERROR_LABEL_HAS_DOT = 512;
const IDNA_ERROR_LABEL_TOO_LONG = 2;
const IDNA_ERROR_LEADING_COMBINING_MARK = 64;
const IDNA_ERROR_LEADING_HYPHEN = 8;
const IDNA_ERROR_PUNYCODE = 256;
const IDNA_ERROR_TRAILING_HYPHEN = 16;
const IDNA_NONTRANSITIONAL_TO_ASCII = 16;
const IDNA_NONTRANSITIONAL_TO_UNICODE = 32;
const IDNA_USE_STD3_RULES = 2;
const INTL_ICU_DATA_VERSION = '65.1';
const INTL_ICU_VERSION = '65.1';
const INTL_IDNA_VARIANT_UTS46 = 1;
const INTL_MAX_LOCALE_LEN = 156;
const ULOC_ACTUAL_LOCALE = 0;
const ULOC_VALID_LOCALE = 1;
const U_AMBIGUOUS_ALIAS_WARNING = -122;
const U_BAD_VARIABLE_DEFINITION = 65536;
const U_BRK_ASSIGN_ERROR = 66053;
const U_BRK_ERROR_LIMIT = 66062;
const U_BRK_ERROR_START = 66048;
const U_BRK_HEX_DIGITS_EXPECTED = 66049;
const U_BRK_INIT_ERROR = 66058;
const U_BRK_INTERNAL_ERROR = 66048;
const U_BRK_MALFORMED_RULE_TAG = 66061;
const U_BRK_MISMATCHED_PAREN = 66055;
const U_BRK_NEW_LINE_IN_QUOTED_STRING = 66056;
const U_BRK_RULE_EMPTY_SET = 66059;
const U_BRK_RULE_SYNTAX = 66051;
const U_BRK_SEMICOLON_EXPECTED = 66050;
const U_BRK_UNCLOSED_SET = 66052;
const U_BRK_UNDEFINED_VARIABLE = 66057;
const U_BRK_UNRECOGNIZED_OPTION = 66060;
const U_BRK_VARIABLE_REDFINITION = 66054;
const U_BUFFER_OVERFLOW_ERROR = 15;
const U_CE_NOT_FOUND_ERROR = 21;
const U_COLLATOR_VERSION_MISMATCH = 28;
const U_DIFFERENT_UCA_VERSION = -121;
const U_ENUM_OUT_OF_SYNC_ERROR = 25;
const U_ERROR_LIMIT = 66818;
const U_ERROR_WARNING_LIMIT = -119;
const U_ERROR_WARNING_START = -128;
const U_FILE_ACCESS_ERROR = 4;
const U_FMT_PARSE_ERROR_LIMIT = 65812;
const U_FMT_PARSE_ERROR_START = 65792;
const U_IDNA_ACE_PREFIX_ERROR = 66564;
const U_IDNA_CHECK_BIDI_ERROR = 66562;
const U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568;
const U_IDNA_ERROR_LIMIT = 66569;
const U_IDNA_ERROR_START = 66560;
const U_IDNA_LABEL_TOO_LONG_ERROR = 66566;
const U_IDNA_PROHIBITED_ERROR = 66560;
const U_IDNA_STD3_ASCII_RULES_ERROR = 66563;
const U_IDNA_UNASSIGNED_ERROR = 66561;
const U_IDNA_VERIFICATION_ERROR = 66565;
const U_IDNA_ZERO_LENGTH_LABEL_ERROR = 66567;
const U_ILLEGAL_ARGUMENT_ERROR = 1;
const U_ILLEGAL_CHARACTER = 65567;
const U_ILLEGAL_CHAR_FOUND = 12;
const U_ILLEGAL_CHAR_IN_SEGMENT = 65564;
const U_ILLEGAL_ESCAPE_SEQUENCE = 18;
const U_ILLEGAL_PAD_POSITION = 65800;
const U_INDEX_OUTOFBOUNDS_ERROR = 8;
const U_INTERNAL_PROGRAM_ERROR = 5;
const U_INTERNAL_TRANSLITERATOR_ERROR = 65568;
const U_INVALID_CHAR_FOUND = 10;
const U_INVALID_FORMAT_ERROR = 3;
const U_INVALID_FUNCTION = 65570;
const U_INVALID_ID = 65569;
const U_INVALID_PROPERTY_PATTERN = 65561;
const U_INVALID_RBT_SYNTAX = 65560;
const U_INVALID_STATE_ERROR = 27;
const U_INVALID_TABLE_FILE = 14;
const U_INVALID_TABLE_FORMAT = 13;
const U_INVARIANT_CONVERSION_ERROR = 26;
const U_MALFORMED_EXPONENTIAL_PATTERN = 65795;
const U_MALFORMED_PRAGMA = 65562;
const U_MALFORMED_RULE = 65537;
const U_MALFORMED_SET = 65538;
const U_MALFORMED_SYMBOL_REFERENCE = 65539;
const U_MALFORMED_UNICODE_ESCAPE = 65540;
const U_MALFORMED_VARIABLE_DEFINITION = 65541;
const U_MALFORMED_VARIABLE_REFERENCE = 65542;
const U_MEMORY_ALLOCATION_ERROR = 7;
const U_MESSAGE_PARSE_ERROR = 6;
const U_MISMATCHED_SEGMENT_DELIMITERS = 65543;
const U_MISPLACED_ANCHOR_START = 65544;
const U_MISPLACED_COMPOUND_FILTER = 65558;
const U_MISPLACED_CURSOR_OFFSET = 65545;
const U_MISPLACED_QUANTIFIER = 65546;
const U_MISSING_OPERATOR = 65547;
const U_MISSING_RESOURCE_ERROR = 2;
const U_MISSING_SEGMENT_CLOSE = 65548;
const U_MULTIPLE_ANTE_CONTEXTS = 65549;
const U_MULTIPLE_COMPOUND_FILTERS = 65559;
const U_MULTIPLE_CURSORS = 65550;
const U_MULTIPLE_DECIMAL_SEPARATORS = 65793;
const U_MULTIPLE_DECIMAL_SEPERATORS = 65793;
const U_MULTIPLE_EXPONENTIAL_SYMBOLS = 65794;
const U_MULTIPLE_PAD_SPECIFIERS = 65798;
const U_MULTIPLE_PERCENT_SYMBOLS = 65796;
const U_MULTIPLE_PERMILL_SYMBOLS = 65797;
const U_MULTIPLE_POST_CONTEXTS = 65551;
const U_NO_SPACE_AVAILABLE = 20;
const U_NO_WRITE_PERMISSION = 30;
const U_PARSE_ERROR = 9;
const U_PARSE_ERROR_LIMIT = 65571;
const U_PARSE_ERROR_START = 65536;
const U_PATTERN_SYNTAX_ERROR = 65799;
const U_PRIMARY_TOO_LONG_ERROR = 22;
const U_REGEX_BAD_ESCAPE_SEQUENCE = 66307;
const U_REGEX_BAD_INTERVAL = 66312;
const U_REGEX_ERROR_LIMIT = 66326;
const U_REGEX_ERROR_START = 66304;
const U_REGEX_INTERNAL_ERROR = 66304;
const U_REGEX_INVALID_BACK_REF = 66314;
const U_REGEX_INVALID_FLAG = 66315;
const U_REGEX_INVALID_STATE = 66306;
const U_REGEX_LOOK_BEHIND_LIMIT = 66316;
const U_REGEX_MAX_LT_MIN = 66313;
const U_REGEX_MISMATCHED_PAREN = 66310;
const U_REGEX_NUMBER_TOO_BIG = 66311;
const U_REGEX_PROPERTY_SYNTAX = 66308;
const U_REGEX_RULE_SYNTAX = 66305;
const U_REGEX_SET_CONTAINS_STRING = 66317;
const U_REGEX_UNIMPLEMENTED = 66309;
const U_RESOURCE_TYPE_MISMATCH = 17;
const U_RULE_MASK_ERROR = 65557;
const U_SAFECLONE_ALLOCATED_WARNING = -126;
const U_SORT_KEY_TOO_SHORT_WARNING = -123;
const U_STANDARD_ERROR_LIMIT = 31;
const U_STATE_OLD_WARNING = -125;
const U_STATE_TOO_OLD_ERROR = 23;
const U_STRINGPREP_CHECK_BIDI_ERROR = 66562;
const U_STRINGPREP_PROHIBITED_ERROR = 66560;
const U_STRINGPREP_UNASSIGNED_ERROR = 66561;
const U_STRING_NOT_TERMINATED_WARNING = -124;
const U_TOO_MANY_ALIASES_ERROR = 24;
const U_TRAILING_BACKSLASH = 65552;
const U_TRUNCATED_CHAR_FOUND = 11;
const U_UNCLOSED_SEGMENT = 65563;
const U_UNDEFINED_SEGMENT_REFERENCE = 65553;
const U_UNDEFINED_VARIABLE = 65554;
const U_UNEXPECTED_TOKEN = 65792;
const U_UNMATCHED_BRACES = 65801;
const U_UNQUOTED_SPECIAL = 65555;
const U_UNSUPPORTED_ATTRIBUTE = 65803;
const U_UNSUPPORTED_ERROR = 16;
const U_UNSUPPORTED_ESCAPE_SEQUENCE = 19;
const U_UNSUPPORTED_PROPERTY = 65802;
const U_UNTERMINATED_QUOTE = 65556;
const U_USELESS_COLLATOR_ERROR = 29;
const U_USING_DEFAULT_WARNING = -127;
const U_USING_FALLBACK_WARNING = -128;
const U_VARIABLE_RANGE_EXHAUSTED = 65565;
const U_VARIABLE_RANGE_OVERLAP = 65566;
const U_ZERO_ERROR = 0;
}
